<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>翼之都, City of Wings</title><link href="http://city.shaform.com/" rel="alternate"></link><link href="http://city.shaform.com/feeds/projects.atom.xml" rel="self"></link><id>http://city.shaform.com/</id><updated>2016-09-10T19:44:00+08:00</updated><entry><title>找出 GitHub 上和 Python 3 不相容的 Python 專案</title><link href="http://city.shaform.com/blog/2016/09/10/py3tracker.html" rel="alternate"></link><published>2016-09-10T19:44:00+08:00</published><updated>2016-09-10T19:44:00+08:00</updated><author><name>Shaform</name></author><id>tag:city.shaform.com,2016-09-10:blog/2016/09/10/py3tracker.html</id><summary type="html">&lt;h1&gt;Porting to Python 3&lt;/h1&gt;
&lt;p&gt;Python 3 已經釋出近八年，原本一片慘紅的 &lt;a href="http://py3readiness.org/"&gt;Python 3 Readiness&lt;/a&gt; 和 &lt;a href="http://python3wos.mybluemix.net/"&gt;PYTHON 3 WALL OF SUPERPOWERS&lt;/a&gt; 都已經接近全綠，真的可以看見社群逐漸朝向 Python 3 的努力。事實上，&lt;a href="http://blog.jupyter.org/2016/07/08/ipython-5-0-released/#endofsupportforpython2"&gt;也開始有些專案漸漸要中止 Python 2 的支援了。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然而其實還是有不少常用的 packages 並不支援 Python 3，像是最近常會用到的 &lt;a href="https://github.com/s3tools/s3cmd"&gt;s3cmd&lt;/a&gt; 就是一例。到了他們的 Issues 頁面瞧瞧，發現其實&lt;a href="https://github.com/s3tools/s3cmd/issues/335"&gt;很早以前就有想支援 Python 3 的聲音&lt;/a&gt;，只是一直沒有人力去做。&lt;/p&gt;
&lt;p&gt;其實，雖然要完全支援的話工程有點浩大，但一小步一小步做起來就在可以處理的範圍之內。有些情況甚至用 &lt;a href="https://docs.python.org/3.5/library/2to3.html"&gt;2to3&lt;/a&gt; 就能有很大幫助了。於是忍不住就順手發了一個 &lt;a href="https://github.com/s3tools/s3cmd/pull/785"&gt;pull request&lt;/a&gt;，結果很順利就被 merge 了。感覺是很低成本的讓自己感覺對世界有貢獻的方法之一。&lt;/p&gt;
&lt;h1&gt;找出可以幫忙的 repositories&lt;/h1&gt;
&lt;p&gt;於是想到，其實說不定 &lt;a href="https://github.com/"&gt;GitHub&lt;/a&gt; 上也還存在許多可以發 pull requests 的 repositories，於是就想寫個類似 Python 3 Readiness 的頁面，專門列出有在 GitHub 上但是卻不支援 Python 3 的專案，讓有強迫症的路人可以簡單找出可以去哪貢獻。&lt;/p&gt;
&lt;p&gt;就這樣，&lt;a href="http://py3tracker.shaform.com/"&gt;py3tracker&lt;/a&gt; 誕生了。&lt;/p&gt;
&lt;p&gt;主要的作法是先用 &lt;a href="https://wiki.python.org/moin/PyPIXmlRpc"&gt;PyPI API&lt;/a&gt; 找出最多人下載的 projects，然後再透過 &lt;a href="https://github.com/brettcannon/caniusepython3"&gt;caniusepython3&lt;/a&gt; 檢查哪些不支援 Python 3，最後再偵測該 project 在 GitHub 上是否有公開原始碼。順便抓星星數用來排序。&lt;/p&gt;
&lt;p&gt;本來想用 GitHub API 但是一下子就超過一天查詢限制，所以只好強抓網頁了。&lt;/p&gt;
&lt;p&gt;最後的網頁樣板則是用 &lt;a href="http://materializecss.com"&gt;materializecss&lt;/a&gt; 快速做成。&lt;/p&gt;
&lt;p&gt;希望對有強迫症的路人有所幫助。&lt;/p&gt;</summary><category term="Python3"></category><category term="2to3"></category><category term="GitHub"></category><category term="py3tracker"></category></entry><entry><title>snappycat: A command line tool to decompress snappy files produced by Hadoop</title><link href="http://city.shaform.com/blog/2015/11/06/snappycat.html" rel="alternate"></link><published>2015-11-06T21:20:00+08:00</published><updated>2015-11-06T21:20:00+08:00</updated><author><name>Shaform</name></author><id>tag:city.shaform.com,2015-11-06:blog/2015/11/06/snappycat.html</id><summary type="html">&lt;p&gt;最近在學習 Spark 的時候常會接觸到 &lt;a href="https://blog.cloudera.com/blog/2011/09/snappy-and-hadoop/"&gt;Snappy&lt;/a&gt; 壓縮而成的檔案。雖然在 Spark
裡只要用 &lt;code&gt;sc.textFile&lt;/code&gt; 就可以直接讀取。可是有時也想把檔案下載到 local
端處理。&lt;/p&gt;
&lt;p&gt;然而因為 Hadoop 的檔案格式不是單純的 Snappy，所以要讀取就會有些麻煩。&lt;/p&gt;
&lt;p&gt;稍微找一下現存的解法似乎都是直接用 Java 去連結 Hadoop
的程式庫，感覺在設置上有些複雜。而且發現目前使用的某個工具似乎在遇到空的 Snappy
flie 時會有錯誤產生。 所以利用空閒的時間稍微研究了一下檔案格式。&lt;/p&gt;
&lt;p&gt;簡單來說，Hadoop 會把每個檔案分成許多個 blocks，而每個 block 各自獨立使用 Snappy
壓縮。在壓縮後的 block 前面，會附上兩個 32-bit 的數字，其中第一個是解壓縮後 block
的大小。第二個則是壓縮後的大小，也就是接在這數字後面的那串資料的大小。&lt;/p&gt;
&lt;p&gt;由於 Spark 存檔案時會把檔案分成許多 partitions，如果資料量太小的話，有的 partition
可能是空的。此時這個空檔案裡只會含兩個 32-bit 的 0。&lt;/p&gt;
&lt;p&gt;處理了這些問題後就寫成了一個很短的 C++ 程式： &lt;a href="https://github.com/shaform/snappycat"&gt;snappycat&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;用法也很簡單，可以把所有檔案當成參數輸入：&lt;/p&gt;
&lt;div class="sh-highlight"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="hll"&gt;./snappycat DIRECTORY/*.snappy
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;p&gt;也可以用 standard input 輸入：&lt;/p&gt;
&lt;div class="sh-highlight"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="hll"&gt;cat DIRECTARY/*.snappy &lt;span class="p"&gt;|&lt;/span&gt; snappycat
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;p&gt;程式會把解壓縮的結果直接輸出到 standard output，所以如果想把檔案存下來則需如下所示：&lt;/p&gt;
&lt;div class="sh-highlight"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="hll"&gt;./snappycat DIRECTORY/*.snappy &amp;gt; output.txt
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;/div&gt;</summary><category term="Hadoop"></category><category term="Spark"></category><category term="snappy"></category><category term="snappycat"></category></entry><entry><title>最低成本的程式協作: CoProgramming</title><link href="http://city.shaform.com/blog/2013/03/05/coprogramming.html" rel="alternate"></link><published>2013-03-05T08:03:00+08:00</published><updated>2013-03-05T08:03:00+08:00</updated><author><name>Shaform</name></author><id>tag:city.shaform.com,2013-03-05:blog/2013/03/05/coprogramming.html</id><summary type="html">&lt;h2&gt;緣起&lt;/h2&gt;
&lt;p&gt;在程式課堂，團隊合作常常是件頭痛的事，若是每個人各自工作，常會產生許多難以整合的版本。即使是一起到電腦教室討論，也常是一個人寫程式，其他人在旁邊看。雖然有版本控制系統等等合作工具，然而我從來沒有成功在一堂課中讓隊友學會其運作(應該說是幾乎，僅有在雙方都早已會使用，或者是由我做所有merge時才曾使用)，事實上，像 git, hg 等等複雜的系統，是否真的適合這種小型專案也尚有可懷疑的地方，尤其，有些作業所有的程式碼都在同一個檔案中，使得版本控制系統用起來十分不順手。&lt;/p&gt;
&lt;p&gt;我突然想起在&lt;a href="http://en.wikipedia.org/wiki/Here_Comes_Everybody"&gt;《Here Comes Everybody》&lt;/a&gt;書裡看過的說法：Wikipedia 的貢獻者中，絕大多數可能只有編輯過一兩行的文章。一家公司如果大部分的員工都只做一點工作，則這家公司多半無法生存。可是在 Wikipedia 的例子裡，合作的成本被降的很低，所以原來不可能利用的小量付出，也能被整合成一個共同成果。&lt;/p&gt;
&lt;p&gt;這確實就是我們遇到的情況，有時在課堂中的程式作業規模是如此的小，任何的合作成本都太過高昂。而且，這種只存在一學期的臨時團隊，根本難以形成向心力。而要求任何人為了一學期的作業學會複雜的版本控制系統更是完全不實際的想法。&lt;/p&gt;
&lt;p&gt;如果要成功整合大家一起完成這種小型的合作、如果要在每個人只寫幾行程式的情況下依然可以合作，唯一的可能性就是要將合作成本壓到極端的低。可是，要怎麼做呢？我的腦中浮現起從前透過 &lt;a href="http://etherpad.org/"&gt;EtherPad&lt;/a&gt; 或者是 &lt;a href="https://docs.google.com/"&gt;Google Docs&lt;/a&gt; 教人寫程式時的場景，這就是了。像這樣即時同步的作法在專業的程式開發中或許會因為無法預期其他人的修改而造成不少問題，但對於小型合作而言，這就是最簡單的協作形式。&lt;/p&gt;
&lt;p&gt;沒有錯，只要在 Google Docs 上協作程式，然後再加上即時編譯執行的功能，免去不斷在 IDE 與 Docs 間不斷複製貼上的成本，就足夠了。這個非常簡單的專案將目標鎖定在程式新手的小型合作，最好的使用情境其實就是兩人互相坐在電腦教室裡，同時使用兩台電腦，邊討論邊寫程式。再也不會有一個人寫程式，其他人在旁邊看的情形了！腦中有了想法後，我就開始試著把他實做出來。&lt;/p&gt;
&lt;p&gt;&lt;div style="width:427px; height:356px; margin: 0 auto;"&gt;&lt;iframe src="http://www.slideshare.net/slideshow/embed_code/16971654" width="427" height="356" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px 1px 0; margin-bottom:5px; max-width: 100%;" allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;經過&lt;/h2&gt;
&lt;p&gt;理論上這應該是個非常簡單的專案，而我其實也只是抱著展示想法的心情，所以是以快速開發作為原則，然而最後卻花了不少時間。問題出在 &lt;a href="https://developers.google.com/drive"&gt;Google Drive SDK&lt;/a&gt; 並沒有支援 C/C++，所以一開始選擇語言時我走了些歧路，原本想採用 Python，可是開發到一半才覺得我不太熟悉用 &lt;a href="http://en.wikipedia.org/wiki/Tkinter"&gt;Tkinter&lt;/a&gt; 製作圖形界面，且效果也不是很好，再考慮到一般 Windows 使用者並沒有安裝 Python 函式庫，&lt;a href="http://www.py2exe.org"&gt;py2exe&lt;/a&gt; 好像也有些 .dll 的問題，所以就放棄了。&lt;/p&gt;
&lt;p&gt;雖然知道 Java 是個不錯的選擇，可是印象中 Java 簡單的程式總要寫一大堆程式碼，實在提不起勁來。這時，我發現 &lt;a href="http://golang.org"&gt;Go&lt;/a&gt; 是個很有趣的語言，雖然他主要是用在系統開發，可是也有人開發&lt;a href="https://github.com/AllenDang/gform"&gt;圖形界面的函式庫&lt;/a&gt;，加上是個編譯語言，很符合我希望使用者能簡單使用這個軟體的需求，於是就決定來學一下 Go 了！這確實是個很簡單易學的語言，我花了一天的時間就讀完基本的教學，準備開始開發。只是突然發現那個圖形函式庫其實根本編譯不起來，而且功能也有限，所以最後我還是決定改用 Java 了。為了使用者的方便，我也打算採用 &lt;a href="http://launch4j.sourceforge.net"&gt;launch4j&lt;/a&gt; 來製作可執行檔，並包入 &lt;a href="http://tdm-gcc.tdragon.net"&gt;TDM-GCC&lt;/a&gt; 以及 Code::Blocks 的 &lt;a href="http://linux.die.net/man/1/cb_console_runner"&gt;cb_console_runner&lt;/a&gt;，讓使用者測試程式結束時視窗不會立即結束。&lt;/p&gt;
&lt;p&gt;目前程式碼可在 &lt;a href="https://github.com/shaform/coprogramming"&gt;coprogramming@github&lt;/a&gt; 觀看。&lt;/p&gt;
&lt;p&gt;本來想製作包裝好的執行檔，但因為不知為何有時編譯出來的程式會被測出木馬&lt;a href="http://comments.gmane.org/gmane.comp.gnu.mingw.user/38529"&gt;（雖然可能是誤判）&lt;/a&gt;，為了避免真的把木馬包進去，所以我決定只放上主程式，想參考研究的朋友可自行下載 TDM-GCC 安裝到 MinGW 子資料夾即可使用，另外如果把 JRE 安裝到 jre7 子資料夾，則可在未安裝 JRE 的電腦上直接執行主程式。&lt;/p&gt;
&lt;p&gt;包好的壓縮檔目前可在 &lt;a href="https://code.google.com/p/coprogramming/downloads/list"&gt;download page&lt;/a&gt; 下載。&lt;/p&gt;
&lt;h2&gt;已知問題&lt;/h2&gt;
&lt;p&gt;由於專案本身只是想要展示想法，所以目前有不少問題：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;由於直接下載編譯執行程式，所以可能有安全性問題。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;目前需要要求存取 Drive 所有檔案的權限，否則無法列出別人分享的程式碼。&lt;/li&gt;
&lt;li&gt;程式碼的標題在 Drive 中有特殊限制，會自動以 coprg 做為結尾，雖然在程式中看不出來。&lt;/li&gt;
&lt;li&gt;需要自行在 Drive 中選取 Tools -&amp;gt; Preferences... 取消 smart quotes 的設定，以免分號被轉換，造成程式無法編譯。&lt;/li&gt;
&lt;li&gt;只支援單檔案編譯。&lt;/li&gt;
&lt;li&gt;只支援 C++。&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;結語&lt;/h2&gt;
&lt;p&gt;其實早就有線上編譯的服務，理論上要做到線上協作、編譯、測試程式應該也可以，且對於使用者而言或許會更加方便。或者可以做一個本機端的伺服器程式，專門接收程式碼與編譯，而將界面寫成 Google Chrome 的擴充套件，這樣就可以使用該套件開啟特定文件，解決目前必須要求存取所有檔案的問題了！（因為本機程式沒有辦法讓使用者針對特定檔案給予權限，我猜測寫成擴充套件應該就可以實做在 Drive 界面裡，在檔案上按右鍵以該套件開啟的功能了吧。）&lt;/p&gt;
&lt;p&gt;這個想法是因為他專門針對新手的小型專案而特別，可是這種合作方式真的只適合新手嗎？即使在專業的環境中，若是在任何檔案上按下右鍵，就能即時同步分享於 Drive 之上，然後在請教同事時，他也能即時在檔案中編輯，而在他編輯的同時，本地端程式碼即時同步，隨時可用原本的方法編譯，這或許也有方便之處？&lt;/p&gt;</summary><category term="軟體開發"></category><category term="CoProgramming"></category><category term="Google Drive"></category></entry><entry><title>稍微整理了一下自由行列的原始碼</title><link href="http://city.shaform.com/blog/2013/02/26/freearray-bugfixes.html" rel="alternate"></link><published>2013-02-26T14:17:00+08:00</published><updated>2013-02-26T14:17:00+08:00</updated><author><name>Shaform</name></author><id>tag:city.shaform.com,2013-02-26:blog/2013/02/26/freearray-bugfixes.html</id><summary type="html">&lt;h2&gt;停擺多年&lt;/h2&gt;
&lt;p&gt;還記得數年前完成了&lt;a href="http://city.shaform.com/blog/2010/02/15/intro-to-freearray.html"&gt;「自由行列輸入法」&lt;/a&gt;的測試版本，雖然一開始還有斷斷續續修正一些 bugs，但到後來這個專案就完全停擺了。當然其中一個重要理由是突然發現 &lt;a href="http://hyperrate.com/thread.php?tid=18200"&gt;gcin 原本就有支援智慧選詞的行列輸入法&lt;/a&gt;，覺得花那麼多力氣重造輪子有點不值得。但其實也是沒有特別的新功能可以開發，而且程式本身寫的太亂不太好維護，加上課業繁忙，所以就沒有投注太多關心。&lt;/p&gt;
&lt;p&gt;gcin 的版本雖然很好，但對 Dvorak 和「行列定符」的支援總是差了那麼一點，而且不知為何總是無法習慣使用 gcin，所以後來就沒有繼續使用。而隨著作業系統的更新，之前的自由行列輸入法也不知為何無法編譯了，於是我就重回注音輸入法的懷抱，和行列輸入法疏離了許久。&lt;/p&gt;
&lt;p&gt;後來剛好又看到行列以及 dvorak 的討論串，加上最近剛好比較有空，就想把之前的程式碼翻修一下，看看能不能動，也順便把原始碼轉到現在比較習慣的 &lt;a href="https://github.com/shaform/ibus-freearray"&gt;GitHub&lt;/a&gt;。雖然只花了幾天時間，不過其實遇到的問題也不少，甚至有些問題的根源還很難弄明白。&lt;/p&gt;
&lt;h2&gt;問題&lt;/h2&gt;
&lt;p&gt;首先遇到的問題是不知為何編譯時所連結的外部函式庫，包含 sqlite3, ibus, freearray 等等，都無法順利連結，使用到的函式都變成了 undefined reference。花了一段時間才發現似乎是一定要透過 libtool 才能順利連結，在 configure.ac 裡加上 AM_PROG_LIBTOOL 以後情況才有所改善。&lt;/p&gt;
&lt;p&gt;但是很奇怪的是，原本我的編譯程序是先將一部分的 object 檔製成暫時的函式庫 libfaft.a，最後再連結在一起，但這個函式庫指向的外部連結也都變成是 undefined reference。除此之外，也遇到 libtool 在連結 c++, c 檔案時無法順利找到 libstdc++ 的問題。最後只有取消中繼函式庫，直接將所有 object 檔連在一起才能解決。&lt;/p&gt;
&lt;p&gt;除此之外，automake 和 autoconf 等等的行為似乎跟以前比起來也有微妙的改變，因此我參考其他專案修改了 autogen.sh，新增 libtoolize 和 autoheader 等指令，讓編譯流程順利進行，雖然其實我也不太清楚這些微妙的改變實際上有什麼作用就是。&lt;/p&gt;
&lt;p&gt;接下來則是 ibus 新版的 ibus_config_set_value, ibus_config_get_value, ibus_config_new 等等的行為已經有所不同，還有許多函式不知為何開始要求傳進去的參數要先經過 g_object_ref_sink 的處理。這些也透過觀察類似專案得到了解法，雖然還沒有時間深入研究。&lt;/p&gt;
&lt;p&gt;最後則是 64bit 環境下 libchewing 的 TreeType 大小會有問題，暫時用強制的型別解決了。&lt;/p&gt;
&lt;h2&gt;結語&lt;/h2&gt;
&lt;p&gt;幾番修正後終於成功啟動了 ibus-freearray，說起來行列輸入法真是不錯，雖然那麼久沒用可是我卻還記得怎麼打字。抱著學習的心態，這次也順便嘗試製作了 .deb 檔案，雖然一開始遇到一些問題，不過也順利解決了。&lt;/p&gt;
&lt;p&gt;雖說如此，這樣匆促的修復應該會隱藏著不少 bugs，而且目前實在也是沒有投入太多心力持續開發這個專案的打算，所以它還是會繼續以測試版的姿態存在下去吧。&lt;/p&gt;
&lt;p&gt;有興趣測試的朋友，所有的檔案都可在 &lt;a href="http://code.google.com/p/freearray/downloads/list"&gt;freearray download page&lt;/a&gt; 下載，若你是使用 64bit Ubuntu，可直接安裝 libfreearray0 和 ibus-freearray 等 .deb 檔。否則的話就參考從前的文件下載 .tar 檔編譯安裝。&lt;/p&gt;
&lt;p&gt;原始碼已經搬移到 Github：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/shaform/libfreearray"&gt;libfreearray&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/shaform/ibus-freearray"&gt;ibus-freearray&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="自由行列"></category><category term="軟體開發"></category><category term="輸入法"></category></entry><entry><title>ibus-faft 開發日誌</title><link href="http://city.shaform.com/blog/2010/02/20/ibus-faft-develop-notes.html" rel="alternate"></link><published>2010-02-20T19:46:00+08:00</published><updated>2010-02-20T19:46:00+08:00</updated><author><name>Shaform</name></author><id>tag:city.shaform.com,2010-02-20:blog/2010/02/20/ibus-faft-develop-notes.html</id><summary type="html">&lt;p&gt;FreeArray for Test for the Input Bus 是基於 ibus 輸入法架構所製作之行列輸入法引擎，其結合來自 libchewing 的斷詞模組實作智慧選字功能，並利用「行列定符」改進原行列的符號輸入。此外，對 dvorak 鍵盤具有完整支援。&lt;/p&gt;
&lt;p&gt;在開發過程中，除了引用大量 libchewing 的程式碼外，也參考了 &lt;a href="http://code.google.com/p/ibus-array/"&gt;ibus-array&lt;/a&gt;, &lt;a href="https://github.com/definite/ibus-chewing"&gt;ibus-chewing&lt;/a&gt; 的程式碼才得以完成。&lt;/p&gt;
&lt;p&gt;時間大約是在 2010 年 2 月初直到 2 月中，連續而密集的開發。&lt;/p&gt;
&lt;h2&gt;libchewing&lt;/h2&gt;
&lt;p&gt;研究 libchewing 其實已經頗久了，直到現在對它的了解也才只是剛好得以把斷詞模組和一部分的輸入處理拿來用而已。為了配合 faft，而對 libchewing 做了些改動，主要是把 Phone 換成 ArrayCode，但也對一部分行為做了小修改，程式碼的改動應該都有用 &lt;code&gt;#ifndef FAFT_CHEWING / #ifdef FAFT_CHEWING&lt;/code&gt; 包了起來，所以應該頗好追蹤的。&lt;/p&gt;
&lt;p&gt;詞樹資料的創建是用了一系列工具轉換出來的，不過因為寫的時候是基於 C++ 版的 libfreearray，而且很亂沒整理，所以並沒有放在 ibus-faft 之中。檔案很大的一部分原因是同一個字有很多行列碼的表示方法，並且文字編碼長度比原新酷音長，另外，不小心把特別碼也轉進去了，不過一直提不起勁來重新轉換 XD。&lt;/p&gt;
&lt;h2&gt;資料處理&lt;/h2&gt;
&lt;p&gt;行列碼和中文字以及鍵盤排列轉換的處理，是從 libfreearray 中 C++ 的版本改過來的，處理中文字、行列定符、詞彙輸入的詞庫、特別碼及簡碼，都是由這部分負責，透過 SQLite 來存取資料。而斷詞用的詞庫，以及簡易符號輸入，則是用 libchewing 的檔案格式，詞彙輸入的詞庫和斷詞的詞庫我並沒有統一資料。另外，我把 libchewing 中使用者詞庫的功能移除以降低開發的複雜度。&lt;/p&gt;
&lt;p&gt;對於 SQLite 其實還不是很熟悉，設了一些 index 也不知是否有必要。主要的參考書藉是&lt;a href="http://apress.com/book/view/9781590596739"&gt;《The Definitive Guide to SQLite》&lt;/a&gt;，以及官方文件&lt;a href="http://www.sqlite.org/docs.html"&gt;《SQLite Documents》&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;核心輸入模組&lt;/h2&gt;
&lt;p&gt;其實原本我想把輸入處理全寫到 ibus-faft-engine 中的 process_key_event()，然後呼叫一些 libchewing 的，或自己寫的函式。想不到後來慢慢把很多東西都移進 faft 中，再由 ibus-faft-engine 來呼叫 faft 裡的函式，所以 ibus-faft 就不用呼叫 libchewing 的函式了。事實上是，現在要把 faft 拿出來，放進 scim 或其它輸入法架構，都變成一件有可能的事。我也因此得以寫了一支 faft-test 程式，配合 gdb 偵錯，對 ibus-faft 的開發有很大幫助。&lt;/p&gt;
&lt;p&gt;對於輸入法資料 FAFTContext 其實改動很多次，本來還另外寫了 FAFTData, FAFTOutput，再試圖引進 libchewing 之中，但最後變得非常複雜，所以還是直接改動 ChewingData, ChewingOutput，再把它們引進 faft 之中。faft 的介面曾改動過非常多次才變成現在的樣子，所以其實在某些地方可能會有一些功能重複或沒有用到的遺跡。另外就是一些狀態變數設了很多，最後好像也不見得有用。&lt;/p&gt;
&lt;p&gt;與 ibus 的介面程式，絕大多數都是參考 ibus-chewing 所做，一部分則是從 ibus-array 而來。&lt;/p&gt;
&lt;h2&gt;關於 Settings&lt;/h2&gt;
&lt;p&gt;在製作 Settings 介面時，我選擇和 ibus-array 一樣，透過 Python 來做，一方面是因為覺得可能比較簡單，二方面是正想學 Python，不能放過每一個機會。過程中比較有趣的是，正值沒有網路的寒假，我又沒有用過 GTK+，在電腦裡只找到一份以前想學 GTK+ 時下載的文件，只是那份寫的是 C，所以跟 Python 又有點不一樣，所以其實很多地方都得「猜猜看」，還得常常用 dir() 之類的。原本製作時是想拿 ibus-array 的來改一下即可，不過最後似乎重寫了絕大部分，順便也是在練習 Python，並一邊閱讀著&lt;a href="http://www.python.org/doc/"&gt;《Python documentation》&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;Autotools&lt;/h2&gt;
&lt;p&gt;在初期，是自己寫 Makefile 來編譯 ibus-faft 的，直到末期才把 Autotools 的部分補了上去。主要是參考 ibus-tmpl 的檔案，以及&lt;a href="http://www.freesoftwaremagazine.com/books/autotools_a_guide_to_autoconf_automake_libtool"&gt;《Autotools: a practitioner's guide to Autoconf, Automake and Libtool》&lt;/a&gt;，才得以完成。&lt;/p&gt;</summary><category term="自由行列"></category><category term="軟體開發"></category><category term="輸入法"></category><category term="ibus"></category></entry><entry><title>簡介自由行列專案</title><link href="http://city.shaform.com/blog/2010/02/15/intro-to-freearray.html" rel="alternate"></link><published>2010-02-15T15:46:00+08:00</published><updated>2010-02-15T15:46:00+08:00</updated><author><name>Shaform</name></author><id>tag:city.shaform.com,2010-02-15:blog/2010/02/15/intro-to-freearray.html</id><summary type="html">&lt;p&gt;本持自由軟體，Release Early, Release Often 之精神，我實在應該趕快把自由行列的程式碼公開出來。不過覺得程式碼實在太醜，而且其實根本也還沒寫出什麼，再者我現在其實是一邊寫一邊學 OOP，因此程式碼常有大幅改動，再者又覺 SVN 操作好麻煩，所以遲遲未發。&lt;/p&gt;
&lt;p&gt;不過為了避免自由行列的想法消失在歷史之中。於是決定，先把自由行列專案的簡介發出。&lt;/p&gt;
&lt;h2&gt;簡易使用&lt;/h2&gt;
&lt;p&gt;行列輸入法雖然是用字根組字的輸入法，然而由於其字根的特性，需要花的記憶心力其實是比較小的，只是為了求快或者避免選字，時常必須記憶特別碼或簡碼。並且因為有些組字必須選字，而有些則不用，使得要時常注意螢幕或者把它的行為強記下來。&lt;/p&gt;
&lt;p&gt;引入智慧選字的功能之後，自由行列的新特性將是簡易。也許不再追求最快的輸入法，但是卻有機會成為組字輸入法中最易上手，選字機會最低的輸入法。每次出字時，不會再有依是否要選字而有的不一致行為，同時我也想將加上特定字尾才能輸出難字的功能去掉，而藏在「w」中的符號表，也被拿到「`」之下。如此一來，輸入的一致性將大為提高。&lt;/p&gt;
&lt;h2&gt;符號輸入&lt;/h2&gt;
&lt;p&gt;符號輸入是自由行列要改進的核心事項之一。除了符號表之外，還有從透過從行列字根發展出的「符根」輸出符號的「行列定符」，以及透過英文鍵盤，輸出全形中文符號的簡易符號輸入。&lt;/p&gt;
&lt;p&gt;使用過行列輸入法的人，即使不用特別說明，只要看到以下符號表，就會明白行列定符的意義。由於和字根非常相似，幾乎不用什麼記憶。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按鍵&lt;/th&gt;
&lt;th&gt;符號&lt;/th&gt;
&lt;th&gt;按鍵&lt;/th&gt;
&lt;th&gt;符號&lt;/th&gt;
&lt;th&gt;按鍵&lt;/th&gt;
&lt;th&gt;符號&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1^&lt;/td&gt;
&lt;td&gt;＝&lt;/td&gt;
&lt;td&gt;5^&lt;/td&gt;
&lt;td&gt;」&lt;/td&gt;
&lt;td&gt;8-&lt;/td&gt;
&lt;td&gt;＼&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1-&lt;/td&gt;
&lt;td&gt;─&lt;/td&gt;
&lt;td&gt;5^5^&lt;/td&gt;
&lt;td&gt;』&lt;/td&gt;
&lt;td&gt;8v&lt;/td&gt;
&lt;td&gt;‘&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2^&lt;/td&gt;
&lt;td&gt;「&lt;/td&gt;
&lt;td&gt;5-&lt;/td&gt;
&lt;td&gt;〉&lt;/td&gt;
&lt;td&gt;8v8v&lt;/td&gt;
&lt;td&gt;“&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2^2^&lt;/td&gt;
&lt;td&gt;『&lt;/td&gt;
&lt;td&gt;5-5-&lt;/td&gt;
&lt;td&gt;》&lt;/td&gt;
&lt;td&gt;9^&lt;/td&gt;
&lt;td&gt;※&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2-&lt;/td&gt;
&lt;td&gt;〈&lt;/td&gt;
&lt;td&gt;5v&lt;/td&gt;
&lt;td&gt;）&lt;/td&gt;
&lt;td&gt;9-&lt;/td&gt;
&lt;td&gt;／&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2-2-&lt;/td&gt;
&lt;td&gt;《&lt;/td&gt;
&lt;td&gt;5v&lt;/td&gt;
&lt;td&gt;）&lt;/td&gt;
&lt;td&gt;9v&lt;/td&gt;
&lt;td&gt;’&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2v&lt;/td&gt;
&lt;td&gt;（&lt;/td&gt;
&lt;td&gt;5v5v&lt;/td&gt;
&lt;td&gt;〕&lt;/td&gt;
&lt;td&gt;9v9v&lt;/td&gt;
&lt;td&gt;”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2v2v&lt;/td&gt;
&lt;td&gt;〔&lt;/td&gt;
&lt;td&gt;5v5v5v&lt;/td&gt;
&lt;td&gt;】&lt;/td&gt;
&lt;td&gt;0^&lt;/td&gt;
&lt;td&gt;：&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2v2v2v&lt;/td&gt;
&lt;td&gt;【&lt;/td&gt;
&lt;td&gt;6-&lt;/td&gt;
&lt;td&gt;、&lt;/td&gt;
&lt;td&gt;0-&lt;/td&gt;
&lt;td&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3-&lt;/td&gt;
&lt;td&gt;！&lt;/td&gt;
&lt;td&gt;7^&lt;/td&gt;
&lt;td&gt;？&lt;/td&gt;
&lt;td&gt;0-0-&lt;/td&gt;
&lt;td&gt;·&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4-&lt;/td&gt;
&lt;td&gt;＋&lt;/td&gt;
&lt;td&gt;7-&lt;/td&gt;
&lt;td&gt;，&lt;/td&gt;
&lt;td&gt;0-0-0-&lt;/td&gt;
&lt;td&gt;…&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4-4-&lt;/td&gt;
&lt;td&gt;＃&lt;/td&gt;
&lt;td&gt;0v&lt;/td&gt;
&lt;td&gt;；&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在輸入完符碼後，按下 Shift+「詞彙鍵」即可輸出符號。&lt;/p&gt;
&lt;p&gt;簡易符號輸入則是像新注音或新酷音那樣，在全型模式下，可輸入英文符號而輸出中文符號。此外，各種符號都可在緩衝區中再按下選字鍵選擇類似的符號。關於簡易符號輸入其實還是有很多改進的方法，有待開發。&lt;/p&gt;
&lt;p&gt;事實上，對於符號輸入的改進，一部分的原因是要完全解決 Jedi 在他文章中所提出的跨 qwerty/dvorak 鍵盤時會遇到的問題。透過行列定符，使用者可以在完全不知道英文鍵盤的符號在哪的情況下輸出符號，讓行列自成一體系。而特意加強的簡易符號輸入，則是可依不同鍵盤輸出對應的中/英文符號。&lt;/p&gt;
&lt;h2&gt;繁簡分離&lt;/h2&gt;
&lt;p&gt;行列輸入法的字根除了可以用來拆繁體字外，其實也可以輸人簡體字。原本的設計是在輸入特定字尾時輸出簡體，但我想將簡體輸入獨立出來做為簡體模式。也就是說，我想嘗試讓自由行列具有做為一個簡體中文輸入法的可能性。&lt;/p&gt;
&lt;h2&gt;不只是輸入法&lt;/h2&gt;
&lt;p&gt;在製作 libfreearray 時，我所考慮的其實不只是輸入法而已，而是要將其發展成自由行列的通用函式庫。例如 typing tutor 或查碼程式，或其他更多的應用，都可基於其上發展。特別是一個可以在 Linux 平台上執行的 typing tutor，更是我將來有機會想實行的方向。覺得行列輸入法實在是一個很好的輸入法，現在似乎不太多人學，實為可惜。&lt;/p&gt;
&lt;h2&gt;手機輸入法&lt;/h2&gt;
&lt;p&gt;行列輸入法做為一個用數字排列字根的輸入法，自然具有成為手機輸入法的潛力，甚至要做到只有十鍵輸入，且不看螢幕都有可能。libfreearray 既然想成為行列的通用函式庫，最後很可能會希望建立起一個具有原始拆字字根，而非減縮後的 30 字根，的文字資料庫。屆時，當可研究如何製作手機輸入法。想來，要把行列字根轉到手機上其實有很多種做法，優缺點也不一，有心人可細細研究。&lt;/p&gt;
&lt;p&gt;也許後來手機的鍵盤將不再有十鍵的限制，但行列做作手機輸入法的可能性還是令人憧憬。&lt;/p&gt;</summary><category term="自由行列"></category><category term="軟體開發"></category><category term="輸入法"></category></entry></feed>